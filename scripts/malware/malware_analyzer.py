
#!/usr/bin/env python3
"""
Malware Analyzer v1.0
Analizador educativo de malware con técnicas de análisis estático
Author: @descambiado
"""

import hashlib
import re
import os
import json
import base64
from typing import Dict, List, Any
from datetime import datetime

class MalwareAnalyzer:
    def __init__(self):
        self.suspicious_patterns = [
            r'exec\(',
            r'eval\(',
            r'subprocess\.',
            r'os\.system',
            r'socket\.',
            r'urllib\.request',
            r'base64\.decode',
            r'__import__',
            r'getattr\(',
            r'setattr\(',
        ]
        
        self.network_indicators = [
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',  # IP addresses
            r'https?://[^\s]+',  # URLs
            r'ftp://[^\s]+',     # FTP URLs
            r'[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Domains
        ]
        
        self.file_operations = [
            r'open\(',
            r'file\(',
            r'write\(',
            r'read\(',
            r'os\.remove',
            r'os\.rename',
            r'shutil\.',
        ]
        
    def calculate_hashes(self, file_content: str) -> Dict[str, str]:
        """Calcula hashes del archivo"""
        content_bytes = file_content.encode('utf-8')
        
        return {
            'md5': hashlib.md5(content_bytes).hexdigest(),
            'sha1': hashlib.sha1(content_bytes).hexdigest(),
            'sha256': hashlib.sha256(content_bytes).hexdigest(),
        }
    
    def detect_suspicious_patterns(self, content: str) -> List[Dict[str, Any]]:
        """Detecta patrones sospechosos"""
        findings = []
        
        for pattern in self.suspicious_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                findings.append({
                    'type': 'suspicious_code',
                    'pattern': pattern,
                    'match': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_network_indicators(self, content: str) -> List[Dict[str, Any]]:
        """Detecta indicadores de red"""
        findings = []
        
        for pattern in self.network_indicators:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append({
                    'type': 'network_indicator',
                    'indicator_type': self._classify_network_indicator(pattern),
                    'value': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_file_operations(self, content: str) -> List[Dict[str, Any]]:
        """Detecta operaciones de archivo"""
        findings = []
        
        for pattern in self.file_operations:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                findings.append({
                    'type': 'file_operation',
                    'operation': pattern,
                    'match': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_obfuscation(self, content: str) -> Dict[str, Any]:
        """Detecta técnicas de ofuscación"""
        obfuscation_indicators = {
            'base64_strings': len(re.findall(r'[A-Za-z0-9+/]{20,}={0,2}', content)),
            'hex_strings': len(re.findall(r'\\x[0-9a-fA-F]{2}', content)),
            'unicode_escapes': len(re.findall(r'\\u[0-9a-fA-F]{4}', content)),
            'long_strings': len([s for s in re.findall(r'["\'][^"\']{50,}["\']', content)]),
            'exec_eval_count': len(re.findall(r'(exec|eval)\s*\(', content, re.IGNORECASE))
        }
        
        obfuscation_score = sum(obfuscation_indicators.values())
        
        return {
            'indicators': obfuscation_indicators,
            'score': obfuscation_score,
            'likely_obfuscated': obfuscation_score > 5
        }
    
    def _get_context(self, content: str, start: int, end: int, context_lines: int = 2) -> str:
        """Obtiene contexto alrededor de una coincidencia"""
        lines = content.split('\n')
        match_line = content[:start].count('\n')
        
        start_line = max(0, match_line - context_lines)
        end_line = min(len(lines), match_line + context_lines + 1)
        
        context_lines_list = lines[start_line:end_line]
        return '\n'.join(f"{start_line + i + 1}: {line}" for i, line in enumerate(context_lines_list))
    
    def _classify_network_indicator(self, pattern: str) -> str:
        """Clasifica el tipo de indicador de red"""
        if 'https?' in pattern:
            return 'url'
        elif 'ftp' in pattern:
            return 'ftp_url'
        elif r'\d{1,3}\.' in pattern:
            return 'ip_address'
        else:
            return 'domain'
    
    def analyze_file(self, file_content: str, filename: str = "unknown") -> Dict[str, Any]:
        """Análisis completo del archivo"""
        analysis_result = {
            'filename': filename,
            'timestamp': datetime.now().isoformat(),
            'file_info': {
                'size': len(file_content),
                'lines': len(file_content.split('\n')),
                'hashes': self.calculate_hashes(file_content)
            },
            'suspicious_patterns': self.detect_suspicious_patterns(file_content),
            'network_indicators': self.detect_network_indicators(file_content),
            'file_operations': self.detect_file_operations(file_content),
            'obfuscation_analysis': self.detect_obfuscation(file_content),
            'risk_assessment': self._assess_risk(file_content)
        }
        
        return analysis_result
    
    def _assess_risk(self, content: str) -> Dict[str, Any]:
        """Evalúa el nivel de riesgo"""
        risk_factors = {
            'suspicious_imports': len(re.findall(r'import\s+(socket|subprocess|os|sys)', content)),
            'network_connections': len(re.findall(r'(connect|send|recv|urlopen)', content)),
            'file_modifications': len(re.findall(r'(write|remove|delete|rename)', content)),
            'process_execution': len(re.findall(r'(exec|system|popen|call)', content)),
            'obfuscation_level': self.detect_obfuscation(content)['score']
        }
        
        total_risk = sum(risk_factors.values())
        
        if total_risk >= 15:
            risk_level = "HIGH"
        elif total_risk >= 8:
            risk_level = "MEDIUM"
        elif total_risk >= 3:
            risk_level = "LOW"
        else:
            risk_level = "MINIMAL"
        
        return {
            'level': risk_level,
            'score': total_risk,
            'factors': risk_factors,
            'recommendations': self._get_recommendations(risk_level)
        }
    
    def _get_recommendations(self, risk_level: str) -> List[str]:
        """Genera recomendaciones basadas en el riesgo"""
        recommendations = {
            "HIGH": [
                "🚨 Ejecutar en entorno sandbox aislado",
                "🔍 Análisis dinámico completo requerido",
                "🛡️ Verificar con múltiples motores antivirus",
                "📋 Documentar IOCs para threat intelligence"
            ],
            "MEDIUM": [
                "⚠️ Revisar manualmente antes de ejecutar",
                "🔒 Ejecutar con privilegios limitados",
                "📊 Monitorear actividad de red y archivos"
            ],
            "LOW": [
                "✅ Probablemente seguro pero verificar contexto",
                "👀 Revisar funcionalidad específica"
            ],
            "MINIMAL": [
                "✅ Bajo riesgo detectado",
                "📝 Revisión básica recomendada"
            ]
        }
        
        return recommendations.get(risk_level, ["Análisis inconcluso"])

def main():
    """Función principal educativa"""
    analyzer = MalwareAnalyzer()
    
    # Muestra de código sospechoso para análisis
    suspicious_sample = '''
import socket
import base64
import subprocess
import os

# Suspicious network activity
s = socket.socket()
s.connect(("192.168.1.100", 4444))

# Obfuscated command
cmd = base64.b64decode("Y21kIC9jIGRpcg==").decode()
subprocess.call(cmd, shell=True)

# File operations
with open("sensitive.txt", "w") as f:
    f.write("secret data")

os.system("del /f important.doc")
'''
    
    print("🔍 Malware Analyzer v1.0")
    print("=" * 40)
    print("🎓 HERRAMIENTA EDUCATIVA DE ANÁLISIS")
    print("=" * 40)
    
    # Realizar análisis
    result = analyzer.analyze_file(suspicious_sample, "suspicious_sample.py")
    
    # Mostrar resultados
    print(f"\n📁 Archivo: {result['filename']}")
    print(f"📊 Tamaño: {result['file_info']['size']} bytes")
    print(f"📋 Líneas: {result['file_info']['lines']}")
    
    print(f"\n🔐 Hashes:")
    for hash_type, hash_value in result['file_info']['hashes'].items():
        print(f"  {hash_type.upper()}: {hash_value}")
    
    print(f"\n⚠️ Patrones Sospechosos Encontrados: {len(result['suspicious_patterns'])}")
    for pattern in result['suspicious_patterns'][:3]:
        print(f"  - Línea {pattern['line']}: {pattern['match']}")
    
    print(f"\n🌐 Indicadores de Red: {len(result['network_indicators'])}")
    for indicator in result['network_indicators'][:3]:
        print(f"  - {indicator['indicator_type']}: {indicator['value']}")
    
    print(f"\n📁 Operaciones de Archivo: {len(result['file_operations'])}")
    for operation in result['file_operations'][:3]:
        print(f"  - Línea {operation['line']}: {operation['match']}")
    
    obfuscation = result['obfuscation_analysis']
    print(f"\n🎭 Análisis de Ofuscación:")
    print(f"  Puntuación: {obfuscation['score']}")
    print(f"  Probablemente ofuscado: {'Sí' if obfuscation['likely_obfuscated'] else 'No'}")
    
    risk = result['risk_assessment']
    print(f"\n🚨 Evaluación de Riesgo: {risk['level']}")
    print(f"📊 Puntuación: {risk['score']}")
    
    print("\n💡 Recomendaciones:")
    for rec in risk['recommendations']:
        print(f"  {rec}")
    
    # Exportar resultado
    output_file = f"malware_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(output_file, 'w') as f:
        json.dump(result, f, indent=2)
    
    print(f"\n✅ Análisis exportado a: {output_file}")
    print("🎓 Análisis educativo completado")

if __name__ == "__main__":
    main()
