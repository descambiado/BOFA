
#!/usr/bin/env python3
"""
Malware Analyzer v1.0
Analizador educativo de malware con tÃ©cnicas de anÃ¡lisis estÃ¡tico
Author: @descambiado
"""

import hashlib
import re
import os
import json
import base64
from typing import Dict, List, Any
from datetime import datetime

class MalwareAnalyzer:
    def __init__(self):
        self.suspicious_patterns = [
            r'exec\(',
            r'eval\(',
            r'subprocess\.',
            r'os\.system',
            r'socket\.',
            r'urllib\.request',
            r'base64\.decode',
            r'__import__',
            r'getattr\(',
            r'setattr\(',
        ]
        
        self.network_indicators = [
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',  # IP addresses
            r'https?://[^\s]+',  # URLs
            r'ftp://[^\s]+',     # FTP URLs
            r'[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',  # Domains
        ]
        
        self.file_operations = [
            r'open\(',
            r'file\(',
            r'write\(',
            r'read\(',
            r'os\.remove',
            r'os\.rename',
            r'shutil\.',
        ]
        
    def calculate_hashes(self, file_content: str) -> Dict[str, str]:
        """Calcula hashes del archivo"""
        content_bytes = file_content.encode('utf-8')
        
        return {
            'md5': hashlib.md5(content_bytes).hexdigest(),
            'sha1': hashlib.sha1(content_bytes).hexdigest(),
            'sha256': hashlib.sha256(content_bytes).hexdigest(),
        }
    
    def detect_suspicious_patterns(self, content: str) -> List[Dict[str, Any]]:
        """Detecta patrones sospechosos"""
        findings = []
        
        for pattern in self.suspicious_patterns:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                findings.append({
                    'type': 'suspicious_code',
                    'pattern': pattern,
                    'match': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_network_indicators(self, content: str) -> List[Dict[str, Any]]:
        """Detecta indicadores de red"""
        findings = []
        
        for pattern in self.network_indicators:
            matches = re.finditer(pattern, content)
            for match in matches:
                findings.append({
                    'type': 'network_indicator',
                    'indicator_type': self._classify_network_indicator(pattern),
                    'value': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_file_operations(self, content: str) -> List[Dict[str, Any]]:
        """Detecta operaciones de archivo"""
        findings = []
        
        for pattern in self.file_operations:
            matches = re.finditer(pattern, content, re.IGNORECASE)
            for match in matches:
                findings.append({
                    'type': 'file_operation',
                    'operation': pattern,
                    'match': match.group(),
                    'line': content[:match.start()].count('\n') + 1,
                    'context': self._get_context(content, match.start(), match.end())
                })
        
        return findings
    
    def detect_obfuscation(self, content: str) -> Dict[str, Any]:
        """Detecta tÃ©cnicas de ofuscaciÃ³n"""
        obfuscation_indicators = {
            'base64_strings': len(re.findall(r'[A-Za-z0-9+/]{20,}={0,2}', content)),
            'hex_strings': len(re.findall(r'\\x[0-9a-fA-F]{2}', content)),
            'unicode_escapes': len(re.findall(r'\\u[0-9a-fA-F]{4}', content)),
            'long_strings': len([s for s in re.findall(r'["\'][^"\']{50,}["\']', content)]),
            'exec_eval_count': len(re.findall(r'(exec|eval)\s*\(', content, re.IGNORECASE))
        }
        
        obfuscation_score = sum(obfuscation_indicators.values())
        
        return {
            'indicators': obfuscation_indicators,
            'score': obfuscation_score,
            'likely_obfuscated': obfuscation_score > 5
        }
    
    def _get_context(self, content: str, start: int, end: int, context_lines: int = 2) -> str:
        """Obtiene contexto alrededor de una coincidencia"""
        lines = content.split('\n')
        match_line = content[:start].count('\n')
        
        start_line = max(0, match_line - context_lines)
        end_line = min(len(lines), match_line + context_lines + 1)
        
        context_lines_list = lines[start_line:end_line]
        return '\n'.join(f"{start_line + i + 1}: {line}" for i, line in enumerate(context_lines_list))
    
    def _classify_network_indicator(self, pattern: str) -> str:
        """Clasifica el tipo de indicador de red"""
        if 'https?' in pattern:
            return 'url'
        elif 'ftp' in pattern:
            return 'ftp_url'
        elif r'\d{1,3}\.' in pattern:
            return 'ip_address'
        else:
            return 'domain'
    
    def analyze_file(self, file_content: str, filename: str = "unknown") -> Dict[str, Any]:
        """AnÃ¡lisis completo del archivo"""
        analysis_result = {
            'filename': filename,
            'timestamp': datetime.now().isoformat(),
            'file_info': {
                'size': len(file_content),
                'lines': len(file_content.split('\n')),
                'hashes': self.calculate_hashes(file_content)
            },
            'suspicious_patterns': self.detect_suspicious_patterns(file_content),
            'network_indicators': self.detect_network_indicators(file_content),
            'file_operations': self.detect_file_operations(file_content),
            'obfuscation_analysis': self.detect_obfuscation(file_content),
            'risk_assessment': self._assess_risk(file_content)
        }
        
        return analysis_result
    
    def _assess_risk(self, content: str) -> Dict[str, Any]:
        """EvalÃºa el nivel de riesgo"""
        risk_factors = {
            'suspicious_imports': len(re.findall(r'import\s+(socket|subprocess|os|sys)', content)),
            'network_connections': len(re.findall(r'(connect|send|recv|urlopen)', content)),
            'file_modifications': len(re.findall(r'(write|remove|delete|rename)', content)),
            'process_execution': len(re.findall(r'(exec|system|popen|call)', content)),
            'obfuscation_level': self.detect_obfuscation(content)['score']
        }
        
        total_risk = sum(risk_factors.values())
        
        if total_risk >= 15:
            risk_level = "HIGH"
        elif total_risk >= 8:
            risk_level = "MEDIUM"
        elif total_risk >= 3:
            risk_level = "LOW"
        else:
            risk_level = "MINIMAL"
        
        return {
            'level': risk_level,
            'score': total_risk,
            'factors': risk_factors,
            'recommendations': self._get_recommendations(risk_level)
        }
    
    def _get_recommendations(self, risk_level: str) -> List[str]:
        """Genera recomendaciones basadas en el riesgo"""
        recommendations = {
            "HIGH": [
                "ğŸš¨ Ejecutar en entorno sandbox aislado",
                "ğŸ” AnÃ¡lisis dinÃ¡mico completo requerido",
                "ğŸ›¡ï¸ Verificar con mÃºltiples motores antivirus",
                "ğŸ“‹ Documentar IOCs para threat intelligence"
            ],
            "MEDIUM": [
                "âš ï¸ Revisar manualmente antes de ejecutar",
                "ğŸ”’ Ejecutar con privilegios limitados",
                "ğŸ“Š Monitorear actividad de red y archivos"
            ],
            "LOW": [
                "âœ… Probablemente seguro pero verificar contexto",
                "ğŸ‘€ Revisar funcionalidad especÃ­fica"
            ],
            "MINIMAL": [
                "âœ… Bajo riesgo detectado",
                "ğŸ“ RevisiÃ³n bÃ¡sica recomendada"
            ]
        }
        
        return recommendations.get(risk_level, ["AnÃ¡lisis inconcluso"])

def main():
    """FunciÃ³n principal educativa"""
    analyzer = MalwareAnalyzer()
    
    # Muestra de cÃ³digo sospechoso para anÃ¡lisis
    suspicious_sample = '''
import socket
import base64
import subprocess
import os

# Suspicious network activity
s = socket.socket()
s.connect(("192.168.1.100", 4444))

# Obfuscated command
cmd = base64.b64decode("Y21kIC9jIGRpcg==").decode()
subprocess.call(cmd, shell=True)

# File operations
with open("sensitive.txt", "w") as f:
    f.write("secret data")

os.system("del /f important.doc")
'''
    
    print("ğŸ” Malware Analyzer v1.0")
    print("=" * 40)
    print("ğŸ“ HERRAMIENTA EDUCATIVA DE ANÃLISIS")
    print("=" * 40)
    
    # Realizar anÃ¡lisis
    result = analyzer.analyze_file(suspicious_sample, "suspicious_sample.py")
    
    # Mostrar resultados
    print(f"\nğŸ“ Archivo: {result['filename']}")
    print(f"ğŸ“Š TamaÃ±o: {result['file_info']['size']} bytes")
    print(f"ğŸ“‹ LÃ­neas: {result['file_info']['lines']}")
    
    print(f"\nğŸ” Hashes:")
    for hash_type, hash_value in result['file_info']['hashes'].items():
        print(f"  {hash_type.upper()}: {hash_value}")
    
    print(f"\nâš ï¸ Patrones Sospechosos Encontrados: {len(result['suspicious_patterns'])}")
    for pattern in result['suspicious_patterns'][:3]:
        print(f"  - LÃ­nea {pattern['line']}: {pattern['match']}")
    
    print(f"\nğŸŒ Indicadores de Red: {len(result['network_indicators'])}")
    for indicator in result['network_indicators'][:3]:
        print(f"  - {indicator['indicator_type']}: {indicator['value']}")
    
    print(f"\nğŸ“ Operaciones de Archivo: {len(result['file_operations'])}")
    for operation in result['file_operations'][:3]:
        print(f"  - LÃ­nea {operation['line']}: {operation['match']}")
    
    obfuscation = result['obfuscation_analysis']
    print(f"\nğŸ­ AnÃ¡lisis de OfuscaciÃ³n:")
    print(f"  PuntuaciÃ³n: {obfuscation['score']}")
    print(f"  Probablemente ofuscado: {'SÃ­' if obfuscation['likely_obfuscated'] else 'No'}")
    
    risk = result['risk_assessment']
    print(f"\nğŸš¨ EvaluaciÃ³n de Riesgo: {risk['level']}")
    print(f"ğŸ“Š PuntuaciÃ³n: {risk['score']}")
    
    print("\nğŸ’¡ Recomendaciones:")
    for rec in risk['recommendations']:
        print(f"  {rec}")
    
    # Exportar resultado
    output_file = f"malware_analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(output_file, 'w') as f:
        json.dump(result, f, indent=2)
    
    print(f"\nâœ… AnÃ¡lisis exportado a: {output_file}")
    print("ğŸ“ AnÃ¡lisis educativo completado")

if __name__ == "__main__":
    main()
