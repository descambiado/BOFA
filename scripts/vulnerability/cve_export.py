#!/usr/bin/env python3
"""
CVE Export - Exportar base de vulnerabilidades
==============================================

Exporta la base local de vulnerabilidades a un archivo JSON.
Uso: python3 cve_export.py --output report.json [--limit 10] [--product web_framework]
"""

import argparse
import json
import sys
from pathlib import Path

_SCRIPT_DIR = Path(__file__).resolve().parent
_DATA_FILE = _SCRIPT_DIR / "cve_data.yaml"


def load_data():
    try:
        import yaml
    except ImportError:
        return []
    if not _DATA_FILE.exists():
        return []
    with open(_DATA_FILE, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f) or {}
    return data.get("entries", [])


def main():
    parser = argparse.ArgumentParser(description="Exportar vulnerabilidades a JSON")
    parser.add_argument("--output", type=str, required=True, help="Archivo de salida JSON")
    parser.add_argument("--limit", type=int, default=100, help="MÃ¡ximo de entradas (default 100)")
    parser.add_argument("--product", type=str, default=None, help="Filtrar por producto")
    args = parser.parse_args()

    entries = load_data()
    if args.product:
        entries = [e for e in entries if (e.get("product") or "").lower() == args.product.lower()]
    entries = entries[: args.limit]

    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump({"count": len(entries), "entries": entries}, f, indent=2)

    print(f"Exportadas {len(entries)} entradas a {args.output}", file=sys.stderr)
    return 0


if __name__ == "__main__":
    sys.exit(main())
