
#!/usr/bin/env python3
"""
Kerberoast Scanner - Advanced Service Account Attack Tool
Developed by @descambiado for BOFA Suite
Educational and authorized testing only
"""

import subprocess
import json
import re
import argparse
import sys
from datetime import datetime

class KerberoastScanner:
    def __init__(self):
        self.version = "1.0"
        self.author = "@descambiado"
        self.results = []
        
    def print_banner(self):
        banner = """
╔══════════════════════════════════════════════════════════════════╗
║                    KERBEROAST SCANNER v1.0                      ║
║              Service Account Attack Simulator                    ║
║                    By @descambiado                               ║
╚══════════════════════════════════════════════════════════════════╝
        """
        print(banner)
        
    def simulate_kerberoasting(self, domain, username=None):
        """Simulates Kerberoasting attack for educational purposes"""
        print(f"[+] Starting Kerberoasting simulation against {domain}")
        
        # Simulate service discovery
        services = [
            "MSSQLSVC/sql01.corp.local:1433",
            "HTTP/web01.corp.local",
            "CIFS/file01.corp.local",
            "LDAP/dc01.corp.local:389"
        ]
        
        vulnerable_accounts = []
        
        for service in services:
            print(f"[*] Checking service: {service}")
            
            # Simulate ticket request
            ticket_info = {
                "service": service,
                "encryption": "RC4-HMAC",
                "vulnerable": True if "SQL" in service or "HTTP" in service else False,
                "timestamp": datetime.now().isoformat()
            }
            
            if ticket_info["vulnerable"]:
                print(f"[!] Vulnerable service found: {service}")
                vulnerable_accounts.append(ticket_info)
            else:
                print(f"[-] Service protected: {service}")
                
        return vulnerable_accounts
    
    def generate_wordlist_attack(self, service_accounts):
        """Simulates password cracking against service accounts"""
        print("\n[+] Simulating password cracking...")
        
        weak_passwords = [
            "Password123!",
            "Service2023",
            "Summer2023!",
            "Admin123",
            "Welcome1!"
        ]
        
        cracked = []
        for account in service_accounts:
            # Simulate cracking attempt
            if "SQL" in account["service"]:
                cracked_pass = weak_passwords[0]
                print(f"[!] CRACKED: {account['service']} -> {cracked_pass}")
                cracked.append({
                    "service": account["service"],
                    "password": cracked_pass,
                    "method": "Dictionary Attack"
                })
            else:
                print(f"[-] Failed to crack: {account['service']}")
                
        return cracked
    
    def detect_spns(self, domain):
        """Simulates SPN enumeration"""
        print(f"\n[+] Enumerating SPNs for domain: {domain}")
        
        spns = [
            {
                "account": "svc-sql",
                "spn": "MSSQLSVC/sql01.corp.local:1433",
                "last_pwd_change": "2023-01-15",
                "risk": "HIGH"
            },
            {
                "account": "svc-web",
                "spn": "HTTP/web01.corp.local",
                "last_pwd_change": "2023-06-01",
                "risk": "MEDIUM"
            },
            {
                "account": "svc-backup",
                "spn": "CIFS/backup.corp.local",
                "last_pwd_change": "2024-01-01",
                "risk": "LOW"
            }
        ]
        
        for spn in spns:
            print(f"[*] Found SPN: {spn['account']} -> {spn['spn']} (Risk: {spn['risk']})")
            
        return spns
    
    def generate_report(self, domain, spns, vulnerable, cracked):
        """Generates comprehensive attack report"""
        report = {
            "scan_info": {
                "domain": domain,
                "timestamp": datetime.now().isoformat(),
                "scanner": "BOFA Kerberoast Scanner v1.0"
            },
            "spn_enumeration": {
                "total_spns": len(spns),
                "high_risk": len([s for s in spns if s["risk"] == "HIGH"]),
                "services": spns
            },
            "kerberoasting": {
                "vulnerable_services": len(vulnerable),
                "cracked_accounts": len(cracked),
                "details": vulnerable
            },
            "cracked_credentials": cracked,
            "recommendations": [
                "Implement strong password policy for service accounts",
                "Enable AES encryption for Kerberos",
                "Use Group Managed Service Accounts (gMSA)",
                "Monitor for TGS requests anomalies",
                "Rotate service account passwords regularly"
            ]
        }
        
        with open(f"kerberoast_report_{domain.replace('.', '_')}.json", "w") as f:
            json.dump(report, f, indent=2)
            
        print(f"\n[+] Report saved to: kerberoast_report_{domain.replace('.', '_')}.json")
        return report
    
    def run_scan(self, domain, username=None, password=None):
        """Main scanning function"""
        self.print_banner()
        
        print("[!] EDUCATIONAL SIMULATION - No real attacks performed")
        print("[!] For authorized penetration testing only\n")
        
        # Step 1: SPN Enumeration
        spns = self.detect_spns(domain)
        
        # Step 2: Kerberoasting Simulation
        vulnerable = self.simulate_kerberoasting(domain, username)
        
        # Step 3: Password Cracking Simulation
        cracked = self.generate_wordlist_attack(vulnerable)
        
        # Step 4: Generate Report
        report = self.generate_report(domain, spns, vulnerable, cracked)
        
        # Summary
        print(f"\n{'='*60}")
        print("KERBEROASTING SIMULATION SUMMARY")
        print(f"{'='*60}")
        print(f"Domain: {domain}")
        print(f"SPNs Found: {len(spns)}")
        print(f"Vulnerable Services: {len(vulnerable)}")
        print(f"Cracked Accounts: {len(cracked)}")
        print(f"{'='*60}")
        
        if cracked:
            print("\n[!] CRITICAL: Service accounts with weak passwords found!")
            for cred in cracked:
                print(f"    - {cred['service']}: {cred['password']}")
        
        return report

def main():
    parser = argparse.ArgumentParser(description="Kerberoast Scanner - Service Account Attack Simulator")
    parser.add_argument("-d", "--domain", required=True, help="Target domain")
    parser.add_argument("-u", "--username", help="Domain username")
    parser.add_argument("-p", "--password", help="Domain password")
    parser.add_argument("--help-attack", action="store_true", help="Show attack methodology")
    
    if len(sys.argv) == 1:
        parser.print_help()
        return
        
    args = parser.parse_args()
    
    if args.help_attack:
        print("""
KERBEROASTING ATTACK METHODOLOGY:
=================================

1. SPN Enumeration:
   - Query Active Directory for Service Principal Names
   - Identify service accounts with SPNs
   - Focus on accounts with weak password policies

2. TGS Request:
   - Request Ticket Granting Service tickets for SPNs
   - Extract encrypted portions containing password hashes
   - No special privileges required

3. Offline Cracking:
   - Use tools like Hashcat or John the Ripper
   - Attempt dictionary and brute force attacks
   - Target RC4-HMAC encrypted tickets (weaker)

4. Post-Exploitation:
   - Use cracked credentials for lateral movement
   - Escalate privileges if service account has high permissions
   - Maintain persistence

DETECTION METHODS:
- Monitor for unusual TGS requests
- Alert on RC4 encryption usage
- Track service account authentication patterns
- Implement honeypot service accounts

MITIGATION:
- Use Group Managed Service Accounts (gMSA)
- Enforce strong passwords for service accounts
- Enable AES encryption for Kerberos
- Regular password rotation
- Principle of least privilege
        """)
        return
    
    scanner = KerberoastScanner()
    scanner.run_scan(args.domain, args.username, args.password)

if __name__ == "__main__":
    main()
